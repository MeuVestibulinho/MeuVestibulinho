// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema


// O que é o prisma ? 

// É uma ferramenta que facilita a interação entre a sua aplicação e um banco de dados relacional,
// sendo amplamente utilizada por sua modernidade, tipagem segura e por simplificar tarefas como modelagem de dados e migrações. 




// Define como o Prisma vai gerar o Prisma Client (biblioteca tipada para acessar o DB):
generator client {
    provider = "prisma-client-js"
}



//Diz ao Prisma qual banco usar (Postgres, MySQL, SQLite, etc.) e onde está a conexão:
datasource db {
    provider = "sqlite"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

// ==========================
// AUTH MODELS (mantidos)
// ==========================

// Usuário da aplicação (aluno/professor/admin, etc.)
model User {
  id            String   @id @default(cuid())    // PK string gerada com cuid(), cuid() é um gerador de IDs únicos
  name          String?                         // nome opcional
  email         String?  @unique                // e-mail opcional, mas único se existir
  emailVerified DateTime?                       // quando o e-mail foi verificado (magic link)
  image         String?                         // avatar/foto (URL)
  accounts      Account[]                       // 1:N -> contas OAuth ligadas a este user (OAuth é um padrão aberto de autorização que permite que você use uma conta de um serviço (Google, Facebook, GitHub, Discord, etc.) para se autenticar em outro sistema sem precisar passar a senha desse serviço.)
  sessions      Session[]                       // 1:N -> sessões ativas (cookies/JWT persistido)
}

// Conta de provedor de login, aqui ficam as informações de autenticação fornecidas pelo provedor de OAuth (google, github, discord, etc.)
model Account {
  id                String  @id @default(cuid()) // PK
  userId            String                         // FK para User
  type              String                         // "oauth" | "oidc" | "email" | "credentials"…
  provider          String                         // nome do provedor, ex.: "google"
  providerAccountId String                         // ID do usuário no provedor (ex.: sub do Google)
  refresh_token     String?                        // token de refresh (se o provedor fornece)
  access_token      String?                        // token de acesso
  expires_at        Int?                           // epoch (segundos) de expiração do access_token
  token_type        String?                        // ex.: "bearer"
  scope             String?                        // escopos concedidos, ex.: "openid email profile"
  id_token          String?                        // id_token (OIDC)
  session_state     String?                        // usado por alguns provedores (opcional)

  // Relação N:1 com User; apaga contas ao apagar o user (Cascade), é um comando do SQL, vimos isso na aula de base de dados relacional
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Restrição única: um mesmo (provider, providerAccountId) só pode existir uma vez
  // Provider é o nome do provedor (ex.: "google")
  // providerAccountId é o ID do usuário nesse provedor (ex.: sub do Google)
  // Isso evita que o mesmo usuário do Google seja cadastrado várias vezes
  @@unique([provider, providerAccountId])
}

// Sessão persistida pelo NextAuth (se usar sessões em BD; com JWT puro pode não usar), aqui ficam os tokens de sessão e quando expiram
// Cada sessão está ligada a um usuário, essa tabela guarda as sessões ativas, que são criadas quando o usuário faz login
// e são removidas quando o usuário faz logout ou a sessão expira
model Session {
  id           String   @id @default(cuid())      // PK (PK = Primary Key = chave primária)
  sessionToken String   @unique                   // token da sessão (chave de lookup[ lookup = busca ])
  userId       String                              // FK -> User (qual usuário tem essa sessão)
  expires      DateTime                            // quando a sessão expira (UTC = tempo universal coordenado, ex.: 2024-06-25T12:00:00Z)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade) // Relação N:1 com User; apaga sessões ao apagar o user (Cascade)
}

// Tokens temporários para verificação (ex.: e-mail de login, reset de senha)
// Eles são criados quando o usuário pede um link mágico por e-mail (magic link) ou um reset de senha
// e são removidos quando usados ou expirados, eles servem para validar que o usuário que clicou no link é o dono do e-mail
// Cada token está ligado a um identificador (normalmente o e-mail do usuário)
model VerificationToken {
  identifier String                               // e-mail ou identificador
  token      String   @unique                     // token enviado ao usuário
  expires    DateTime                             // validade do token

  // Restrição única composta para evitar duplicatas por identificador+token, garantindo que cada token seja único para um dado identificador (identificador é o e-mail do usuário)
  @@unique([identifier, token])
}

// ==========================
// APP MODELS (novos + principais)
// ==========================

// Enum de dificuldade (usado por Question)
enum Difficulty {
  EASY    // Questão de nível fácil
  MEDIUM  // Questão de nível médio
  HARD    // Questão de nível difícil
}

// --- Topic: Tópico principal (ex.: Matemática)
model Topic {
  id        String   @id @default(cuid())
  // Identificador único do tópico.

  name      String   @unique
  // Nome do tópico (único), ex.: "Matemática".

  createdAt DateTime @default(now())
  // Data/hora de criação do registro.

  updatedAt DateTime @updatedAt
  // Atualizado automaticamente a cada update.

  subtopics Subtopic[]
  // Relação 1:N com Subtopic (lista de subtópicos). Back-relation opcional e segura.

  questions Question[]
  // Back-relation opcional para listar questões deste tópico.
}

// --- Subtopic: Subtópico dentro de um Topic (ex.: Frações)
model Subtopic {
  id        String   @id @default(cuid())
  // Identificador único do subtópico.

  name      String
  // Nome do subtópico, ex.: "Frações".

  topicId   String
  // FK para Topic.

  createdAt DateTime @default(now())
  // Data/hora de criação.

  updatedAt DateTime @updatedAt
  // Atualizado automaticamente a cada update.

  topic     Topic    @relation(fields: [topicId], references: [id])
  // Relação obrigatória com o Topic pai.

  questions Question[]
  // Back-relation opcional para listar questões deste subtópico.

  @@index([topicId])
  // Índice para acelerar filtros por topicId.

  @@unique([topicId, name])
  // Evita subtópicos duplicados dentro do mesmo tópico.
}

// --- Tag: Marcadores temáticos/assuntos (N:N com Question)
model Tag {
  id        String   @id @default(cuid())
  // Identificador único da Tag.

  name      String   @unique
  // Nome da tag (único), ex.: "Frações", "Proporções".

  createdAt DateTime @default(now())
  // Data/hora de criação.

  updatedAt DateTime @updatedAt
  // Atualizado automaticamente a cada update.

  questions QuestionTag[]
  // Back-relation via tabela de junção QuestionTag.
}

// --- SourceExam: Prova de origem (ex.: ETEC 2023)
model SourceExam {
  id        String   @id @default(cuid())
  // Identificador único da prova de origem.

  name      String
  // Nome da prova/organizador, ex.: "ETEC", "IFSP".

  year      Int
  // Ano da prova, ex.: 2023.

  createdAt DateTime @default(now())
  // Data/hora de criação.

  updatedAt DateTime @updatedAt
  // Atualizado automaticamente a cada update.

  questions Question[]
  // Back-relation opcional para listar questões dessa prova.

  @@unique([name, year])
  // Garante unicidade por organizador+ano (ex.: "ETEC+2023").
}

// --- Question: a questão em si (enunciado, alternativas, solução, etc.)
model Question {
  id            String   @id @default(cuid()) 
  // Identificador único da questão (gerado automaticamente com cuid).

  statement     String
  // Enunciado da questão (texto principal apresentado ao aluno).

  choices       Json
  // Alternativas de resposta (armazenadas em formato JSON, ex.: array de strings
  // ou objetos com { key: "A", text: "..." }).

  answerKey     String
  // Gabarito: identifica a alternativa correta (ex.: "A", "B", "C" ou o texto/índice).

  hints         Json?
  // Dicas/auxílios opcionais para ajudar o aluno (pode conter uma lista em JSON).

  solution      Json?
  // Solução detalhada/explicação (pode incluir passos, fórmulas ou rich text em JSON).

  difficulty    Difficulty
  // Nível de dificuldade da questão (EASY, MEDIUM, HARD).

  timeTargetS   Int?
  // Tempo-alvo em segundos estimado para resolver a questão (opcional).

  isPublic      Boolean  @default(false)
  // Indica se a questão está liberada (true) ou ainda em staging/oculta (false).

  fingerprint   String   @unique
  // Hash único (ex.: SHA1 de statement+sourceExam) para idempotência do import (evita duplicatas).

  topicId       String
  // FK: Tópico principal ao qual a questão pertence.

  subtopicId    String?
  // FK opcional: Subtópico específico.

  sourceExamId  String?
  // FK opcional: Prova/ano de origem.

  createdAt     DateTime @default(now())
  // Data/hora de criação do registro.

  updatedAt     DateTime @updatedAt
  // Data/hora da última atualização automática.

  topic         Topic     @relation(fields: [topicId], references: [id])
  // Relação com o Tópico (obrigatória).

  subtopic      Subtopic? @relation(fields: [subtopicId], references: [id])
  // Relação com o Subtópico (opcional).

  sourceExam    SourceExam? @relation(fields: [sourceExamId], references: [id])
  // Relação com a Prova de origem (opcional).

  tags          QuestionTag[]
  // Relação N:N com Tags (intermediada pelo model QuestionTag).

  // Índices para otimizar consultas e filtros:
  @@index([topicId])
  @@index([subtopicId])
  @@index([sourceExamId])
  @@index([difficulty])
  @@index([isPublic])
  @@index([createdAt])
}

// --- QuestionTag: tabela de junção N:N (Question <-> Tag)
model QuestionTag {
  questionId String
  // ID da questão (chave estrangeira).

  tagId      String
  // ID da tag (chave estrangeira).

  question   Question @relation(fields: [questionId], references: [id])
  // Relação com a questão.

  tag        Tag      @relation(fields: [tagId], references: [id])
  // Relação com a tag.

  @@id([questionId, tagId])
  // Chave composta que garante unicidade da combinação questão + tag.
}

// Nesse arquivo definimos as tabelas do banco de dados e seus relacionamentos, que serão usados pelo Prisma Client para fazer consultas ao banco de dados de forma tipada e segura.
// Cada um desses models vira uma tabela no banco de dados relacional (PostgreSQL, MySQL, SQLite, etc.) e o Prisma Client gera código TypeScript para interagir com essas tabelas de forma fácil e segura.
